import multiprocessing
import threading
import time


def find_primes_step_1(start, end):
    lst_prime = []
    t_start = time.time()
    for num in range(start, end + 1):
        for i in range(2, int(num ** 0.5), 1):
            print("", end='')
            if num % i == 0:
                break
        else:
            lst_prime.append(num)
    print(f"{time.time() - t_start : > 8.3f}", end="")


if __name__ == "__main__":
    data = [(3, 100000), (100001, 200000), (200001, 300000),
            (300001, 400000), (400001, 500000), (500001, 600000),
            (600001, 700000), (700001, 800000)]
    tim_start = time.time()
    for dt in data:
        find_primes_step_1(dt[0], dt[1])
    print(f" общее время {time.time() - tim_start : > 8.3f} ")
    ti1 = f" общее время {time.time() - tim_start : > 8.3f} "
    res2 = []
    tim_start = time.time()
    for dt in data:
        th = threading.Thread(target=find_primes_step_1, args=(dt[0], dt[1]))
        th.start()
        res2.append(th)
    for th in res2:
        th.join()
    print(f" общее время {time.time() - tim_start : > 8.3f} ")
    ti2 = f" общее время {time.time() - tim_start : > 8.3f} "
    res3 = []
    tim_start = time.time()
    for dt in data:
        mult = multiprocessing.Process(target=find_primes_step_1, args=(dt[0], dt[1]))
        mult.start()
        res3.append(mult)
    for mult in res3:
        mult.join()
    print(f" общее время {time.time() - tim_start : > 8.3f} ")
    ti3 = f" общее время {time.time() - tim_start : > 8.3f} "
    print(ti1)
    print(ti2)
    print(ti3)

    '''Ответы на вопросы:
    
       Если не выполнить функцию start(), но выполнить join(), будет выброшена ошибка
    AssertionError: can only join a started process
       Eсли запустить функцию start(), но не выполнить join(), интерпретатор не будет ждать
    завершение обозначенного потока или процесса и при возможности продолжит
    выполнение основного потока или просесса. И это может привести к наружению логики
    и непредсказуемости результата. появляется ассинхронность.
    
       Кто быстрее? пытаюсь разобраться... смотрю на результаты...
       Потокам без разницы, сколько у вас ядер, одна дверь на всех, могут строем пройти, по порядку,
    могут всей кучей делить кто первый кто последний, но дверь то к ядру одна. Но зато, если кучей,
    те кто должен быть посдедним, может стать первым! т.е. в кругу потоков, не щелкай вводом.
       Если ядро потокам особо то и не нужно, так, сходить туда - сюда... Тогда, да, быстренько сходят,
    и друг другу мешать не будут. Так что,если потоки сами по себе, без ядра, то быстренько все сделают.
    
       Процессы... если у вас одно ядро... то да же и не знаю. Но если ядер много, то каждому
    процессу своё ядро! Всей толпе легче и быстрее через нескольго дверей проходить, нежели через одну.
    Но, если расчеты маааленькие, то пока строется одна дверь, вторая, третья.... то быстрее проскочить
    через черный ход ).
    
       Вот и получается, кто быстрее не поймешь, пока не выяснишь, что за процессы,
    какие там потоки, расчеты и  сколько ядер.
    А поток это или процесс.. 
    как сказал Гермес Триждывеличайший - что в большом, то и в малом, что в малом, то и в большом.
    Хотя конечно, тут еще и с памятью нужно разобраться...
    
       Если брать маленький интервал в 100 циклов, то последовательное выполнение 
    кода имеет перимущество в скорости. При этом можно примерно оценить расходы на организацию
    многопоточого и многопроцессного подходов. 
       Значительное увеличение интервала заметно не влияет на общую скорость последовательного и 
    многопоточного выполнения, но существенно повышает скорость многопроцессного выполнения.
    
       В конкретном случае (в задаче) наиболее быстрый способ - последовательное выполнение кода.
    У многопроцессного варианта, в данном примере, много расходов на организацию трех процессов.
    
       Эх, многословие какое то :( .. а если будет принт каждого значения... такой... прииииинт...
    
       Принт принту рознь!
       Да, принтуй не принтуй, в данном случае последовательный подход вне конкуренции.
       Но если подумать, что! и где печатать, и как много..
       то практика может обескуражить теорию )))
       
       общее время  494.064  последовательно
       общее время  490.370  конкурентно
       общее время  229.403  параллельно

    2.503   4.003   4.922   5.636   6.230   6.764   7.213   7.680   общее время   44.950 
    120.778 199.263 243.961 275.283 291.909 303.856 304.205 306.123 общее время  306.128 
    5.105   7.717   9.228  10.268  10.781  11.337  11.765  12.293   общее время   12.493 
    Жизнь программ бывает сложной.....
    ортогональный способ еще не придумали.
    '''
