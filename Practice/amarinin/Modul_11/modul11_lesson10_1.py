import multiprocessing
import threading
import time


def find_primes_step_1(start, end):
    lst_prime = []
    t_start = time.time()
    for num in range(start, end + 1):
        for i in range(2, int(num ** 0.5), 1):
            if num % i == 0:
                break
        else:
            lst_prime.append(num)
    print(f"{time.time() - t_start : > 8.3f}", end="")


if __name__ == "__main__":
    data = [(3, 10000), (10001, 20000), (20001, 30000)]
    tim_start = time.time()
    for dt in data:
        find_primes_step_1(dt[0], dt[1])
    print(f" общее время {time.time() - tim_start : > 8.3f} ")
    res2 = []
    tim_start = time.time()
    for dt in data:
        th = threading.Thread(target=find_primes_step_1, args=(dt[0], dt[1]))
        th.start()
        res2.append(th)
    for th in res2:
        th.join()
    print(f" общее время {time.time() - tim_start : > 8.3f} ")
    res3 = []
    tim_start = time.time()
    for dt in data:
        mult = multiprocessing.Process(target=find_primes_step_1, args=(dt[0], dt[1]))
        mult.start()
        res3.append(mult)
    for mult in res3:
        mult.join()
    print(f" общее время {time.time() - tim_start : > 8.3f} ")

    '''Ответы на вопросы:
    
       Если не выполнить функцию start(), но выполнить join(), будет выброшена ошибка
    AssertionError: can only join a started process
       Eсли запустить функцию start(), но не выполнить join(), интерпретатор не будет ждать
    завершение обозначенного потока или процесса и при возможности продолжит
    выполнение основного потока или просесса. И это может привести к наружению логики
    и непредсказуемости результата. появляется ассинхронность.
    
       Кто быстрее? пытаюсь разобраться... смотрю на результаты...
       Потокам без разницы, сколько у вас ядер, одна дверь на всех, могут строем пройти, по порядку,
    могут всей кучей делить кто первый кто последний, но дверь то к ядру одна. Но зато, если кучей,
    те кто должен быть посдедним, может стать первым! т.е. в кругу потоков, не щелкай вводом.
       Если ядро потокам особо то и не нужно, так, сходить туда - сюда... Тогда, да, быстренько сходят,
    и друг другу мешать не будут. Так что,если потоки сами по себе, без ядра, то быстренько все сделают.
    
       Процессы... если у вас одно ядро... то да же и не знаю. Но если ядер много, то каждому
    процессу своё ядро! Всей толпе легче и быстрее через нескольго дверей проходить, нежели через одну.
    Но, если расчеты маааленькие, то пока строется одна дверь, вторая, третья.... то быстрее проскочить
    через черный ход ).
    
       Вот и получается, кто быстрее не поймешь, пока не выяснишь, что за процессы,
    какие там потоки, расчеты и  сколько ядер.
    А поток это или процесс.. 
    как сказал Гермес Триждывеличайший - что в большом, то и в малом, что в малом, то и в большом.
    Хотя конечно, тут еще и с памятью нужно разобраться...
    
       Если брать маленький интервал в 100 циклов, то последовательное выполнение 
    кода имеет перимущество в скорости. При этом можно примерно оценить расходы на организацию
    многопоточого и многопроцессного подходов. 
       Значительное увеличение интервала заметно не влияет на общую скорость последовательного и 
    многопоточного выполнения, но существенно повышает скорость многопроцессного выполнения.
    
       В конкретном случае (в задаче) наиболее быстрый способ - последовательное выполнение кода.
    У многопроцессного варианта, в данном примере, много расходов на организацию трех процессов.

    '''
